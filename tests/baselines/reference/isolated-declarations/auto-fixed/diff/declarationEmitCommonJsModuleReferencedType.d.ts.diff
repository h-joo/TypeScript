// [[Reason: checker.typeToTypeNode deliberately fails on types that originate from node_modules.]] ////

//// [tests/cases/compiler/declarationEmitCommonJsModuleReferencedType.ts] ////

===================================================================
--- TSC	declarations
+++ DTE	declarations
@@ -1,8 +1,15 @@
 
+
+//// [r/entry.d.ts]
+import { RootProps } from "root";
+export declare const x: invalid;
+export declare const y: RootProps;
+//# sourceMappingURL=entry.d.ts.map
 /// [Errors] ////
 
 r/entry.ts(3,14): error TS2742: The inferred type of 'x' cannot be named without a reference to 'foo/node_modules/nested'. This is likely not portable. A type annotation is necessary.
+r/entry.ts(3,14): error TS9010: Variable must have an explicit type annotation with --isolatedDeclarations.
 
 
 ==== r/node_modules/foo/node_modules/nested/index.d.ts (0 errors) ====
     export interface NestedProps {}
@@ -20,12 +27,15 @@
 ==== node_modules/root/index.d.ts (0 errors) ====
     export interface RootProps {}
     
     export function bar(): RootProps;
-==== r/entry.ts (1 errors) ====
+==== r/entry.ts (2 errors) ====
     import { foo } from "foo";
     import { RootProps, bar } from "root";
     export const x = foo();
                  ~
 !!! error TS2742: The inferred type of 'x' cannot be named without a reference to 'foo/node_modules/nested'. This is likely not portable. A type annotation is necessary.
+                 ~
+!!! error TS9010: Variable must have an explicit type annotation with --isolatedDeclarations.
+!!! related TS9028 r/entry.ts:3:14: Add a type annotation to the variable x.
     export const y: RootProps = bar();
     
\ No newline at end of file
